# /etc/skel/.bashrc
#
# AUTHOR: Daniel Klopp 
# COPYRIGHT: GNU Public License 
# OS Support: Theoretically OSX and Linux, not always thoroughly tested
# DESCRIPTION: My BASH profile.  I tend to source it from .bashrc and keep
# this in github.  I do have other profiles for "Work specific".  I keep those


if [[ $- != *i* ]] ; then
	# Shell is non-interactive.  Be done now!
   # This handles odd cases with scp 
	return
fi

PATH=~/Documents/projects/scripts/bin:$PATH
export PATH
# Put your fun stuff here.

alias cp='/bin/cp -i'
if [ `uname` == "Darwin" ]; then
	alias ls='/bin/ls -aFG'
   alias emacs='/Applications/Emacs.app/Contents/MacOS/Emacs'
else
	alias ls='/bin/ls -aF --color=always'
fi
alias mv='/bin/mv -i'
alias rm='/bin/rm -i'

## Colors
COLOR_RED="\[\e[31;40m\]"
COLOR_GREEN="\[\e[32;40m\]"
COLOR_YELLOW="\[\e[33;40m\]"
COLOR_BLUE="\[\e[34;40m\]"
COLOR_MAGENTA="\[\e[35;40m\]"
COLOR_CYAN="\[\e[36;40m\]"
COLOR_RED_BOLD="\[\e[31;1m\]"
COLOR_GREEN_BOLD="\[\e[32;1m\]"
COLOR_YELLOW_BOLD="\[\e[33;1m\]"
COLOR_BLUE_BOLD="\[\e[34;1m\]"
COLOR_MAGENTA_BOLD="\[\e[35;1m\]"
COLOR_CYAN_BOLD="\[\e[36;1m\]"
COLOR_NONE="\[\e[0m\]"

KEYSIZE=4
TERMDISPLAYSETUP=$((RANDOM%KEYSIZE))
case "$TERMDISPLAYSETUP" in
	0)
		PS1="${COLOR_MAGENTA_BOLD}: ${COLOR_RED_BOLD}\u${COLOR_MAGENTA_BOLD} @ ${COLOR_RED_BOLD}\h ${COLOR_MAGENTA_BOLD}; "
	;;
	1)
		PS1="${COLOR_GREEN_BOLD}: ${COLOR_CYAN_BOLD}\u${COLOR_GREEN_BOLD} @ ${COLOR_CYAN_BOLD}\h ${COLOR_GREEN_BOLD}; "
	;;
	2)
		PS1="${COLOR_MAGENTA_BOLD}: ${COLOR_BLUE_BOLD}\u${COLOR_MAGENTA_BOLD} @ ${COLOR_BLUE_BOLD}\h ${COLOR_MAGENTA_BOLD}; "
	;;
	3)
		PS1="${COLOR_RED_BOLD}: ${COLOR_BLUE_BOLD}\u${COLOR_RED_BOLD} @ ${COLOR_BLUE_BOLD}\h ${COLOR_RED_BOLD}; "
	;;
	*)
		echo Warning, we received a value of
		echo $TERMDISPLAYSETUP when we should not
		echo have exceeded the key size of $KEYSIZE
		echo Fix this please.
	;;
esac
export PS1

unset TERMDISPLAYSETUP
unset KEYSIZE

# There can never be too much history
export HISTSIZE=12000
export HISTTIMEFORMAT="%Y-%m-%d %T: "


if [ `uname` != "Darwin" ]; then
   export GTK_IM_MODULE=ibus
   export XMODIFIERS=@im=ibus
   export QT_IM_MODULE=ibus
   alias ]='/usr/bin/xdg-open'
fi


#[[ -s "$HOME/.pythonbrew/etc/bashrc" ]] && source "$HOME/.pythonbrew/etc/bashrc"
alias pydev='source "$HOME/.pythonbrew/etc/bashrc"'

function new_python_package {
# I cannot remember where I grabbed this from
# I found it off some website and modified it when
# I was creating lots of Python modules.
# Perhaps there is a better way to do this now,
# like with ruby's bundle gem $mygem
mkdir "$1"
cd "$1"
mkdir -p bin "$1"/test docs 
touch CHANGES.txt
echo 'This belongs to Dan Klopp (dsklopp@gmail.com)' > LICENSE.txt
echo 'and whose exclusive property and all rights entailed' >> LICENSE.txt

echo "v0.99a, " `date '+%B %d, %Y'` >> CHANGES.txt

echo 'include *.txt' > MANIFEST.in
echo 'recursive-include docs *.txt' >> MANIFEST.in

cat <<'EOF' > README.txt
===========
Towel Stuff
===========

Towel Stuff provides such and such and so and so. You might find
it most useful for tasks involving <x> and also <y>. Typical usage
often looks like this::

    #!/usr/bin/env python

    from towelstuff import location
    from towelstuff import utils

    if utils.has_towel():
        print "Your towel is located:", location.where_is_my_towel()

(Note the double-colon and 4-space indent formatting above.)

Paragraphs are separated by blank lines. *Italics*, **bold**,
and ``monospace`` look like this.


A Section
=========

Lists look like this:

* First

* Second. Can be multiple lines
  but must be indented properly.


Contributors
============

A Sub-Section
-------------

Numbered lists look like you'd expect:

1. hi there

2. must be going

Urls are http://like.this and links can be
written `like this <http://www.example.com/foo/bar>`_.

EOF

echo "are reserved for this python package called $1" >> LICENSE.txt
echo '#!/usr/bin/env python' > setup.py
echo '#!/usr/bin/env python' > "$1"/__init__.py
echo '#!/usr/bin/env python' > "$1"/test_location.py
echo '#!/usr/bin/env python' > "$1"/test_utils.py
echo '#!/usr/bin/env python' > "$1"/test/__init__.py
echo '#!/usr/bin/env python' > "$1"/test/test_location.py
echo '#!/usr/bin/env python' > "$1"/test/test_utils.py


cat <<EOF > setup.py
from distutils.core import setup

setup(
    name='$1',
    version='0.9a',
    author='Dan Klopp',
    author_email='dsklopp@gmail.com',
    packages=['$1', '$1.test'],
    #scripts=['bin/stowe-towels.py','bin/wash-towels.py'],
    scripts=[]
    url='http://pypi.python.org/pypi/$1/',
    license='LICENSE.txt',
    description='$1',
    long_description=open('README.txt').read(),
    install_requires=[],
    #install_requires=[
    #    "Django >= 1.1.1",
    #    "caldav == 0.1.4",
    #],
)
EOF
# Go back to the parent directory, like
# all other such tools
cd ..
}

# JSON stuff
jl () {
  jltmp="/tmp/jl-$$"
  if [[ -f "$1" ]]; then
    python -m simplejson.tool $1 >"$jltmp" 2>&1 && { echo "JSON Good"; rm "$jltmp"; return 0; } || { cat "$jltmp"; rm "$jltmp"; return 1; }
  else
    echo "Usage: jl <file.json>"
  fi
}

ppj () {
  ppjtmp="/tmp/ppj-$$"
  infile="$1"
  outfile="$2"
  command="python -m simplejson.tool"
  if [[ $@ ]]; then
    if jl "$infile" >"$ppjtmp"; then
      if [[ "$outfile" ]]; then
        if [[ "$infile" == "$outfile" ]]; then
          cp "$infile" "$ppjtmp" && infile="$ppjtmp"
        fi
        $command "$infile" | sed 's/  / /g' > "$outfile"
      else
        $command "$infile" | sed 's/  / /g'
      fi
    else
      cat "$ppjtmp"
    fi
  else
    echo "Usage: ppj <file1.json> [ <file2.json> | <file1.json> ]"
  fi
  [[ -f "$ppjtmp" ]] && rm "$ppjtmp"
}

PATH=$HOME/.rbenv/bin:$PATH
PATH=$HOME/.pyenv/bin:$PATH
export PATH
which pyenv &> /dev/null
if [ $? -eq 0 ]; then
   eval "$(pyenv init -)"
   pyvers=`python -V 2>&1`
   echo "Using Python: $pyvers"
else
   echo "You do not have Python properly configured for pyenv to function"
fi
export DOCKER_HOST=tcp://localhost:4243

which rbenv &> /dev/null
if [ $? -eq 0 ]; then
   eval "$(rbenv init -)"
   which ruby &> /dev/null
   if [ $? -eq 0 ]; then
      rubvers=`ruby -v | awk '{print $2}'`
      echo "Using Ruby: $rubvers"
   else
      echo ERROR: rbenv is installed but ruby was not 1>&2
   fi
else
   echo "You do not have Ruby properly configured for rbenv to function"
fi

# Set the JAVA_HOME if applicable on a MAC
if [ `uname` == "Darwin" ]; then
   if [ ! -f /usr/libexec/java_home ]; then
      echo "WARNING: You have no java installed, java_home not found"
   else
      JAVA_HOME=`/usr/libexec/java_home`
      #JAVA_HOME=`dirname $JAVA_HOME`
      #JAVA_HOME=`dirname $JAVA_HOME`
      STUDIO_JDK=`dirname $JAVA_HOME`
      STUDIO_JDK=`dirname $STUDIO_JDK`
      export JAVA_HOME
      export STUDIO_JDK
      echo JAVA_HOME=$JAVA_HOME
   fi
fi

function enable_kivy {
   pythonversion=`python -V 2>&1 |awk '{print $2}'`
   if [ "$pythonversion" != "2.7.9" ]; then
      echo ERROR, only Python 2.7.9 was configured to use Kivy, refusing to configure. 1>&2
      return
   fi
   NEWPATH=""
   for apath in `echo $PATH | tr ':' ' '`; do
      if [ "$apath" == "$HOME/.pyenv/versions/2.7.9/bin" ]; then
         continue
      fi
      if [ "$apath" == "$HOME/.buildozer/android//platform/android-sdk-21/platform-tools" ]; then
         continue
      fi
      if [ -z "$NEWPATH" ]; then
         NEWPATH=$apath
      else
         NEWPATH=$apath:$NEWPATH
      fi
   done
   export PATH=~/.pyenv/versions/2.7.9/bin:~/.buildozer/android//platform/android-sdk-21/platform-tools:$NEWPATH
}

function install_pyenv {
  which pyenv &> /dev/null
  if [ $? -eq 0 ]; then
    echo ERROR: pyenv in path, aborting 1>&2
    return 1
  fi
  cd $HOME
  git clone https://github.com/yyuu/pyenv.git ~/.pyenv
  export PYENV_ROOT="$HOME/.pyenv" 
  export PATH="$PYENV_ROOT/bin"
  pyenv rehash
  echo
  echo You must add:
  echo 'export PYENV_ROOT="$HOME/.pyenv"'
  echo 'export PATH="$PYENV_ROOT/bin:$PATH"'
  echo to your path
  

}

function install_rbenv {
  which rbenv &> /dev/null
  if [ $? -eq 0 ]; then
    echo ERROR: rbenv in path, aborting 1>&2
    return 1
  fi
  cd $HOME
  git clone https://github.com/sstephenson/rbenv.git ~/.rbenv
  git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
  export PATH="$HOME/.rbenv/bin:$PATH"
  rbenv rehash
  echo
  echo You must add:
  echo 'export PATH="$HOME/.rbenv/bin:$PATH"'
  echo to your path
  
}
function myhelp {
  cat ~/.bash_danklopp | grep ^function
}

function configure_vim {
  if [ ! -e "$1" ]; then
    echo The .vimrc file "$1" does not exist, please give the absolute path
    echo to your .vimrc file.
    return 1
  fi
  if [ ! -d ~/.vim/bundle ]; then
    mkdir -p ~/.vim/bundle
  fi
  if [ "$HOME/.vimrc" != "$1" ]; then
    ln -s "$1" "$HOME/.vimrc"
  fi
  if [ ! -e ~/.vim/bundle/Vundle.vim ]; then
    git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim
  fi
}

function configure_terraform {
   cd /tmp
   mkdir terraform
   cd terraform
   wget https://dl.bintray.com/mitchellh/terraform/terraform_0.4.2_linux_amd64.zip
   sudo mv * /usr/bin/
}
function create_chefrepo_for_chefzero {
   mkdir chef-repo
   cd chef-repo
   mkdir data_bags roles environments .chef cookbooks
   cat <<EOF > .chef/knife.rb
current_dir = File.dirname(__FILE__)
user = ENV['OPSCODE_USER'] || ENV['USER']
node_name                user
client_key               "#{current_dir}/#{user}.pem"
validation_key           "#{current_dir}/validator.pem"
chef_server_url          "http://127.0.0.1:8889/"
cookbook_path            ["#{current_dir}/../cookbooks"]
EOF
   cat <<EOF > .chef/$USER.pem
-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAqNsLXIc4NtfZlyAP7yWKpZ8WlslETygSbgsWjz/r2+iF1iEaEisXbckdjP1f
cUsgxOvRVpm6f3iU9jWyE5DQG6m44cjSCPstMQnMz6BiS7Rv+oAEDAyT+AoYnq9vAYPmrjy+xaiG
ozTw1MBzlOqkZ1oVWpQE8Fr5sbC017Y9euMCObkV2jpM3t6fH27QQc+eJ/e5BRap+anmbiDBwTpP
7986AcA1LQ9OtHqsY7Hzub+gbyMORzQOE/eP6E86sF6qla3/z+uUozGOzSaPqKwBjeSdD0bNMIOe
1BpfmPfSEB31DXGHLiBxNEtuicz4XEVF0jVZP8RT87WySVKrA0e+tQIDAQABAoIBAE9ZJ9yiWmND
Saf/1B0QajfsK4ROLkB4VzjJEx/b7O0ZNpNqWMMC5u6bXLydcFVf9ZU0L9pfQUmXk4CjuPwCyBjH
x+6qHTFFP3ZU4Z8MAkULFLgFomE7I+mibPFdBXAT2Lo2J3vg9uwI+8cubOIk5X7/0RsQhcWhKsc6
f7ECnZ95+7fPxo/mJ3eIAqAiXhxtgWA/ggnhgRqvLSaPQQc3HRBn4RMRRxW3yxfKL5VGq8a2SsoV
uH3JqcMxbL4aHtso9G5NXnr8QO+rJwFl3X+4ZOXKxeyMo8K2cJYTkFzKKrT2ONdscEGV4E8UtCAQ
00g8N1KBwnGJ6MFj6nULTGluwqECgYEA4pZYvt4z8qJDgMNmJZoUHxQDWsvCfLl4VoSvpZWxDEfm
+VI/JQ8EUAv2THTS7ppRb+d9/P/3OoKuzgE1S9K6TmGCIkE0eAhsNgpCcrdXVbYR3ITbpluDUhXF
Z8sBGuJ1UAx3vaLSIxAqX5WYeU695y4S4bWcTtH15rmYy+5f6x0CgYEAvsY8Hn7VJ/UBpMV6Wsg4
iN0idV762+2SxzeVknP4WaWNICJfI21lIxZMRUVk02tObGBwVibCZ1kqPAaMckaWwYoQ6OrvtDEi
inUHasasAWsuf+AGOACyxEGcJO4e0bgWXwP5ZjWpPq4kNQbu+/saqZsGAWACT+Z3mjXg2E0HtnkC
gYADsioeaud0BLuPJSDMajf7zcrEN2Cjwi65Uo6+57MsnRuiY3oOM7GBUMCivKEYLUI4zhDbCJ3S
wYDycUiaRQSu9J43ytJ9Rr3lH8O3tU/iYQbnju86RnHc6+f9am1JL/pz5NArMrW0xrW6O2lySRuF
4tWCAwFas8gMDGj2opvD7QKBgCdbHevsnmyvzrb/Rk6UH5WciQ9NmNLmH/GZNfIQmptj28lVTesx
Fjw2zWU8+5/h8zvIaWRcep53do8Lis3IYjFrGjHyxaCWwllt6ynL8pAYXG9k9+N1wWtbXasAtLrv
Dy5q03iSeWfE5RNLauHw239By+tcsx1oniPiGZCF06GBAoGAOQJ/yiHBX+J1iVrsJYwl0/4iBw5y
yMtLsNQOkwMdzyXMkGmz8JbQJJxIZZCXcMahI9RXsuGCviVh5w0WZgseE893YQU8rdqbfT0Pbtzk
aThRm0LNYGrRDxKj/f/EnBPsNDb0U2o+EVr/NB4z2ZZJwnXUtTGdKnYcq+2gLPKMuW4=
-----END RSA PRIVATE KEY-----
EOF
   cp .chef/$USER.pem .chef/validator.pem
}

function export_aws_creds {
   if [ ! -f ~/.aws/credentials ]; then
      echo ERROR: No file ~/.aws/credentials found  1>&2
      return 1
   fi
   if [ `grep -q aws_access_key_id ~/.aws/credentials` ]; then
      echo ERROR: aws_access_key_id not set in ~/.aws/credentials  1>&2
      return 1
   fi
   if [ `grep -q aws_secret_access_key ~/.aws/credentials` ]; then
      echo ERROR: aws_secret_access_key not set in ~/.aws/credentials  1>&2
      return 1
   fi
   key=`grep aws_access_key_id ~/.aws/credentials | tr -d ' ' | awk -F= '{print $2}'`
   secret=`grep aws_secret_access_key ~/.aws/credentials | tr -d ' ' | awk -F= '{print $2}'`
   export AWS_ACCESS_KEY_ID=$key
   export AWS_SECRET_ACCESS_KEY=$secret
}
